{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport React from 'react';\nimport { List, Map } from 'immutable';\nimport PropTypes from 'prop-types';\nimport Paths from './Paths';\n\nvar Canvas = function (_React$Component) {\n  _inherits(Canvas, _React$Component);\n\n  function Canvas(props) {\n    _classCallCheck(this, Canvas);\n\n    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));\n\n    _this.handlePointerDown = _this.handlePointerDown.bind(_this);\n    _this.handlePointerMove = _this.handlePointerMove.bind(_this);\n    _this.handlePointerUp = _this.handlePointerUp.bind(_this);\n    _this.getCoordinates = _this.getCoordinates.bind(_this);\n    _this.canvas = React.createRef();\n    return _this;\n  }\n  /* Add event listener to Mouse up and Touch up to\n  release drawing even when point goes out of canvas */\n\n\n  Canvas.prototype.componentDidMount = function componentDidMount() {\n    document.addEventListener('pointerup', this.handlePointerUp);\n  };\n\n  Canvas.prototype.componentWillUnmount = function componentWillUnmount() {\n    document.removeEventListener('pointerup', this.handlePointerUp);\n  }; // Converts mouse coordinates to relative coordinate based on the absolute position of svg\n\n\n  Canvas.prototype.getCoordinates = function getCoordinates(pointerEvent) {\n    var boundingArea = this.canvas.current.getBoundingClientRect();\n    return new Map({\n      x: pointerEvent.pageX - boundingArea.left,\n      y: pointerEvent.pageY - boundingArea.top\n    });\n  };\n  /* Mouse Handlers - Mouse down, move and up */\n\n\n  Canvas.prototype.handlePointerDown = function handlePointerDown(pointerEvent) {\n    // Allow only chosen pointer type\n    var _props = this.props,\n        allowOnlyPointerType = _props.allowOnlyPointerType,\n        onPointerDown = _props.onPointerDown;\n    if (allowOnlyPointerType !== 'all' && pointerEvent.pointerType !== allowOnlyPointerType) return;\n    if (pointerEvent.pointerType === 'mouse' && pointerEvent.button !== 0) return;\n    var point = this.getCoordinates(pointerEvent);\n    onPointerDown(point);\n  };\n\n  Canvas.prototype.handlePointerMove = function handlePointerMove(pointerEvent) {\n    var _props2 = this.props,\n        isDrawing = _props2.isDrawing,\n        allowOnlyPointerType = _props2.allowOnlyPointerType,\n        onPointerMove = _props2.onPointerMove;\n    if (!isDrawing) return; // Allow only chosen pointer type\n\n    if (allowOnlyPointerType !== 'all' && pointerEvent.pointerType !== allowOnlyPointerType) return;\n    var point = this.getCoordinates(pointerEvent);\n    onPointerMove(point);\n  };\n\n  Canvas.prototype.handlePointerUp = function handlePointerUp(pointerEvent) {\n    if (pointerEvent.pointerType === 'mouse' && pointerEvent.button !== 0) return; // Allow only chosen pointer type\n\n    var _props3 = this.props,\n        allowOnlyPointerType = _props3.allowOnlyPointerType,\n        onPointerUp = _props3.onPointerUp;\n    if (allowOnlyPointerType !== 'all' && pointerEvent.pointerType !== allowOnlyPointerType) return;\n    onPointerUp();\n  };\n  /* Mouse Handlers ends */\n  // Creates a image from SVG and renders it on canvas, then exports the canvas as image\n\n\n  Canvas.prototype.exportImage = function exportImage(imageType) {\n    var _this2 = this;\n\n    return new Promise(function (resolve, reject) {\n      try {\n        var canvas = _this2.canvas.current;\n        var img = document.createElement('img');\n        img.src = 'data:image/svg+xml;base64,' + btoa(canvas.innerHTML);\n        console.log(canvas);\n\n        img.onload = function () {\n          var renderCanvas = document.createElement('canvas');\n          renderCanvas.setAttribute('width', canvas.offsetWidth);\n          renderCanvas.setAttribute('height', canvas.offsetHeight);\n          renderCanvas.getContext('2d').drawImage(img, 0, 0);\n          resolve(renderCanvas.toDataURL('image/' + imageType));\n        };\n      } catch (e) {\n        reject(e);\n      }\n    });\n  };\n\n  Canvas.prototype.exportSvg = function exportSvg() {\n    var _this3 = this;\n\n    return new Promise(function (resolve, reject) {\n      try {\n        resolve(_this3.canvas.current.innerHTML);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  };\n  /* Finally!!! Render method */\n\n\n  Canvas.prototype.render = function render() {\n    var _props4 = this.props,\n        width = _props4.width,\n        height = _props4.height,\n        canvasColor = _props4.canvasColor,\n        background = _props4.background,\n        style = _props4.style,\n        paths = _props4.paths;\n    return React.createElement('div', {\n      role: 'presentation',\n      ref: this.canvas,\n      style: _extends({\n        touchAction: 'none',\n        width: width,\n        height: height\n      }, style),\n      onPointerDown: this.handlePointerDown,\n      onPointerMove: this.handlePointerMove,\n      onPointerUp: this.handlePointerUp\n    }, React.createElement('svg', {\n      version: '1.1',\n      baseProfile: 'full',\n      xmlns: 'http://www.w3.org/2000/svg',\n      style: {\n        width: '100%',\n        height: '100%',\n        background: background + ' ' + canvasColor\n      }\n    }, React.createElement('g', {\n      id: 'canvasPenStrokes'\n    }, React.createElement(Paths, {\n      paths: paths\n    }))));\n  };\n\n  return Canvas;\n}(React.Component);\n/* Default settings */\n\n\nCanvas.defaultProps = {\n  width: '100%',\n  height: '100%',\n  canvasColor: 'white',\n  background: '',\n  allowOnlyPointerType: 'all',\n  style: {\n    border: '0.0625rem solid #9c9c9c',\n    borderRadius: '0.25rem'\n  }\n};\n/* Props validation */\n\nCanvas.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  paths: PropTypes.instanceOf(List).isRequired,\n  isDrawing: PropTypes.bool.isRequired,\n  onPointerDown: PropTypes.func.isRequired,\n  onPointerMove: PropTypes.func.isRequired,\n  onPointerUp: PropTypes.func.isRequired,\n  width: PropTypes.string,\n  height: PropTypes.string,\n  canvasColor: PropTypes.string,\n  background: PropTypes.string,\n  allowOnlyPointerType: PropTypes.string,\n  style: PropTypes.objectOf(PropTypes.string)\n} : {};\nexport default Canvas;","map":null,"metadata":{},"sourceType":"module"}