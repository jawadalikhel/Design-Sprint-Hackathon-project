{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport React from 'react';\nimport { List, Map, mergeDeep } from 'immutable';\nimport PropTypes from 'prop-types';\nimport Canvas from './Canvas';\n\nvar SvgSketchCanvas = function (_React$Component) {\n  _inherits(SvgSketchCanvas, _React$Component);\n\n  function SvgSketchCanvas(props) {\n    _classCallCheck(this, SvgSketchCanvas);\n\n    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));\n\n    _this.state = {\n      drawMode: true,\n      isDrawing: false,\n      reset: false,\n      resetStore: new List(),\n      redoStore: new List(),\n      currentPaths: new List()\n    };\n    _this.handlePointerDown = _this.handlePointerDown.bind(_this);\n    _this.handlePointerMove = _this.handlePointerMove.bind(_this);\n    _this.handlePointerUp = _this.handlePointerUp.bind(_this);\n    _this.exportImage = _this.exportImage.bind(_this);\n    _this.exportSvg = _this.exportSvg.bind(_this);\n    _this.exportPaths = _this.exportPaths.bind(_this);\n    _this.loadPaths = _this.loadPaths.bind(_this);\n    _this.eraseMode = _this.eraseMode.bind(_this);\n    _this.clearCanvas = _this.clearCanvas.bind(_this);\n    _this.undo = _this.undo.bind(_this);\n    _this.redo = _this.redo.bind(_this);\n    _this.svgCanvas = React.createRef();\n    return _this;\n  }\n  /* Mouse Handlers - Mouse down, move and up */\n\n\n  SvgSketchCanvas.prototype.handlePointerDown = function handlePointerDown(point) {\n    var _props = this.props,\n        strokeColor = _props.strokeColor,\n        strokeWidth = _props.strokeWidth,\n        canvasColor = _props.canvasColor,\n        eraserWidth = _props.eraserWidth;\n    this.setState(function (state) {\n      return {\n        isDrawing: true,\n        redoStore: new List(),\n        currentPaths: state.currentPaths.push(new Map({\n          drawMode: state.drawMode,\n          strokeColor: state.drawMode ? strokeColor : canvasColor,\n          strokeWidth: state.drawMode ? strokeWidth : eraserWidth,\n          paths: new List([point])\n        }))\n      };\n    });\n  };\n\n  SvgSketchCanvas.prototype.handlePointerMove = function handlePointerMove(point) {\n    var isDrawing = this.state.isDrawing;\n    if (!isDrawing) return;\n    this.setState(function (state) {\n      return {\n        currentPaths: state.currentPaths.updateIn([state.currentPaths.size - 1], function (pathMap) {\n          return pathMap.updateIn(['paths'], function (list) {\n            return list.push(point);\n          });\n        })\n      };\n    });\n  };\n\n  SvgSketchCanvas.prototype.handlePointerUp = function handlePointerUp() {\n    this.setState({\n      isDrawing: false\n    });\n  };\n  /* Mouse Handlers ends */\n\n  /* Canvas operations */\n\n\n  SvgSketchCanvas.prototype.eraseMode = function eraseMode(erase) {\n    this.setState({\n      drawMode: !erase\n    });\n  };\n\n  SvgSketchCanvas.prototype.clearCanvas = function clearCanvas() {\n    this.setState(function (state) {\n      return {\n        reset: true,\n        resetStore: state.currentPaths,\n        currentPaths: new List()\n      };\n    });\n  };\n\n  SvgSketchCanvas.prototype.undo = function undo() {\n    var _state = this.state,\n        currentPaths = _state.currentPaths,\n        reset = _state.reset;\n    if (currentPaths.isEmpty() && !reset) return;\n    this.setState(function (state) {\n      if (state.reset) {\n        return {\n          reset: false,\n          resetStore: new List(),\n          redoStore: state.currentPaths,\n          currentPaths: state.resetStore\n        };\n      }\n\n      return {\n        redoStore: state.redoStore.push(state.currentPaths.get(-1)),\n        currentPaths: state.currentPaths.pop()\n      };\n    });\n  };\n\n  SvgSketchCanvas.prototype.redo = function redo() {\n    var redoStore = this.state.redoStore;\n    if (redoStore.isEmpty()) return;\n    this.setState(function (state) {\n      return {\n        redoStore: state.redoStore.pop(),\n        currentPaths: state.currentPaths.push(state.redoStore.get(-1))\n      };\n    });\n  };\n  /* Exporting options */\n  // Creates a image from SVG and renders it on canvas, then exports the canvas as image\n\n\n  SvgSketchCanvas.prototype.exportImage = function exportImage(imageType) {\n    var _this2 = this;\n\n    return new Promise(function (resolve, reject) {\n      _this2.svgCanvas.current.exportImage(imageType).then(function (data) {\n        resolve(data);\n      }).catch(function (e) {\n        reject(e);\n      });\n    });\n  };\n\n  SvgSketchCanvas.prototype.exportSvg = function exportSvg() {\n    var _this3 = this;\n\n    return new Promise(function (resolve, reject) {\n      _this3.svgCanvas.current.exportSvg().then(function (data) {\n        resolve(data);\n      }).catch(function (e) {\n        reject(e);\n      });\n    });\n  };\n\n  SvgSketchCanvas.prototype.exportPaths = function exportPaths() {\n    var currentPaths = this.state.currentPaths;\n    return new Promise(function (resolve, reject) {\n      try {\n        resolve(currentPaths);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  };\n\n  SvgSketchCanvas.prototype.loadPaths = function loadPaths(paths) {\n    this.setState(function (prevState) {\n      return {\n        currentPaths: mergeDeep(prevState.currentPaths, paths)\n      };\n    });\n  };\n  /* Finally!!! Render method */\n\n\n  SvgSketchCanvas.prototype.render = function render() {\n    var _props2 = this.props,\n        width = _props2.width,\n        height = _props2.height,\n        canvasColor = _props2.canvasColor,\n        background = _props2.background,\n        style = _props2.style,\n        allowOnlyPointerType = _props2.allowOnlyPointerType;\n    var _state2 = this.state,\n        currentPaths = _state2.currentPaths,\n        isDrawing = _state2.isDrawing;\n    return React.createElement(Canvas, {\n      ref: this.svgCanvas,\n      width: width,\n      height: height,\n      canvasColor: canvasColor,\n      background: background,\n      allowOnlyPointerType: allowOnlyPointerType,\n      style: style,\n      paths: currentPaths,\n      isDrawing: isDrawing,\n      onPointerDown: this.handlePointerDown,\n      onPointerMove: this.handlePointerMove,\n      onPointerUp: this.handlePointerUp\n    });\n  };\n\n  return SvgSketchCanvas;\n}(React.Component);\n/* Default settings */\n\n\nSvgSketchCanvas.defaultProps = {\n  width: '100%',\n  height: '100%',\n  canvasColor: 'white',\n  strokeColor: 'red',\n  background: '',\n  strokeWidth: 4,\n  eraserWidth: 8,\n  allowOnlyPointerType: 'pen',\n  style: {\n    border: '0.0625rem solid #9c9c9c',\n    borderRadius: '0.25rem'\n  }\n};\n/* Props validation */\n\nSvgSketchCanvas.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  width: PropTypes.string,\n  height: PropTypes.string,\n  strokeColor: PropTypes.string,\n  canvasColor: PropTypes.string,\n  background: PropTypes.string,\n  strokeWidth: PropTypes.number,\n  eraserWidth: PropTypes.number,\n  allowOnlyPointerType: PropTypes.string,\n  style: PropTypes.objectOf(PropTypes.string)\n} : {};\nexport default SvgSketchCanvas;","map":null,"metadata":{},"sourceType":"module"}