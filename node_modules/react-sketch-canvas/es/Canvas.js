var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React from 'react';
import { List, Map } from 'immutable';
import PropTypes from 'prop-types';
import Paths from './Paths';

var Canvas = function (_React$Component) {
  _inherits(Canvas, _React$Component);

  function Canvas(props) {
    _classCallCheck(this, Canvas);

    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

    _this.handlePointerDown = _this.handlePointerDown.bind(_this);
    _this.handlePointerMove = _this.handlePointerMove.bind(_this);
    _this.handlePointerUp = _this.handlePointerUp.bind(_this);
    _this.getCoordinates = _this.getCoordinates.bind(_this);

    _this.canvas = React.createRef();
    return _this;
  }

  /* Add event listener to Mouse up and Touch up to
  release drawing even when point goes out of canvas */


  Canvas.prototype.componentDidMount = function componentDidMount() {
    document.addEventListener('pointerup', this.handlePointerUp);
  };

  Canvas.prototype.componentWillUnmount = function componentWillUnmount() {
    document.removeEventListener('pointerup', this.handlePointerUp);
  };

  // Converts mouse coordinates to relative coordinate based on the absolute position of svg


  Canvas.prototype.getCoordinates = function getCoordinates(pointerEvent) {
    var boundingArea = this.canvas.current.getBoundingClientRect();

    return new Map({
      x: pointerEvent.pageX - boundingArea.left,
      y: pointerEvent.pageY - boundingArea.top
    });
  };

  /* Mouse Handlers - Mouse down, move and up */

  Canvas.prototype.handlePointerDown = function handlePointerDown(pointerEvent) {
    // Allow only chosen pointer type
    var _props = this.props,
        allowOnlyPointerType = _props.allowOnlyPointerType,
        onPointerDown = _props.onPointerDown;

    if (allowOnlyPointerType !== 'all' && pointerEvent.pointerType !== allowOnlyPointerType) return;

    if (pointerEvent.pointerType === 'mouse' && pointerEvent.button !== 0) return;

    var point = this.getCoordinates(pointerEvent);

    onPointerDown(point);
  };

  Canvas.prototype.handlePointerMove = function handlePointerMove(pointerEvent) {
    var _props2 = this.props,
        isDrawing = _props2.isDrawing,
        allowOnlyPointerType = _props2.allowOnlyPointerType,
        onPointerMove = _props2.onPointerMove;


    if (!isDrawing) return;

    // Allow only chosen pointer type
    if (allowOnlyPointerType !== 'all' && pointerEvent.pointerType !== allowOnlyPointerType) return;

    var point = this.getCoordinates(pointerEvent);

    onPointerMove(point);
  };

  Canvas.prototype.handlePointerUp = function handlePointerUp(pointerEvent) {
    if (pointerEvent.pointerType === 'mouse' && pointerEvent.button !== 0) return;

    // Allow only chosen pointer type
    var _props3 = this.props,
        allowOnlyPointerType = _props3.allowOnlyPointerType,
        onPointerUp = _props3.onPointerUp;

    if (allowOnlyPointerType !== 'all' && pointerEvent.pointerType !== allowOnlyPointerType) return;

    onPointerUp();
  };

  /* Mouse Handlers ends */

  // Creates a image from SVG and renders it on canvas, then exports the canvas as image


  Canvas.prototype.exportImage = function exportImage(imageType) {
    var _this2 = this;

    return new Promise(function (resolve, reject) {
      try {
        var canvas = _this2.canvas.current;

        var img = document.createElement('img');
        img.src = 'data:image/svg+xml;base64,' + btoa(canvas.innerHTML);
        console.log(canvas);

        img.onload = function () {
          var renderCanvas = document.createElement('canvas');
          renderCanvas.setAttribute('width', canvas.offsetWidth);
          renderCanvas.setAttribute('height', canvas.offsetHeight);
          renderCanvas.getContext('2d').drawImage(img, 0, 0);

          resolve(renderCanvas.toDataURL('image/' + imageType));
        };
      } catch (e) {
        reject(e);
      }
    });
  };

  Canvas.prototype.exportSvg = function exportSvg() {
    var _this3 = this;

    return new Promise(function (resolve, reject) {
      try {
        resolve(_this3.canvas.current.innerHTML);
      } catch (e) {
        reject(e);
      }
    });
  };

  /* Finally!!! Render method */

  Canvas.prototype.render = function render() {
    var _props4 = this.props,
        width = _props4.width,
        height = _props4.height,
        canvasColor = _props4.canvasColor,
        background = _props4.background,
        style = _props4.style,
        paths = _props4.paths;


    return React.createElement(
      'div',
      {
        role: 'presentation',
        ref: this.canvas,
        style: _extends({
          touchAction: 'none',
          width: width,
          height: height
        }, style),
        onPointerDown: this.handlePointerDown,
        onPointerMove: this.handlePointerMove,
        onPointerUp: this.handlePointerUp
      },
      React.createElement(
        'svg',
        {
          version: '1.1',
          baseProfile: 'full',
          xmlns: 'http://www.w3.org/2000/svg',
          style: {
            width: '100%',
            height: '100%',
            background: background + ' ' + canvasColor
          }
        },
        React.createElement(
          'g',
          { id: 'canvasPenStrokes' },
          React.createElement(Paths, { paths: paths })
        )
      )
    );
  };

  return Canvas;
}(React.Component);

/* Default settings */

Canvas.defaultProps = {
  width: '100%',
  height: '100%',
  canvasColor: 'white',
  background: '',
  allowOnlyPointerType: 'all',
  style: {
    border: '0.0625rem solid #9c9c9c',
    borderRadius: '0.25rem'
  }
};

/* Props validation */

Canvas.propTypes = process.env.NODE_ENV !== "production" ? {
  paths: PropTypes.instanceOf(List).isRequired,
  isDrawing: PropTypes.bool.isRequired,
  onPointerDown: PropTypes.func.isRequired,
  onPointerMove: PropTypes.func.isRequired,
  onPointerUp: PropTypes.func.isRequired,
  width: PropTypes.string,
  height: PropTypes.string,
  canvasColor: PropTypes.string,
  background: PropTypes.string,
  allowOnlyPointerType: PropTypes.string,
  style: PropTypes.objectOf(PropTypes.string)
} : {};

export default Canvas;